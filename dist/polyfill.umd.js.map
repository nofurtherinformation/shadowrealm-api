{"version":3,"file":"polyfill.umd.js","sources":["../src/helpers.ts","../src/ShadowRealm.ts","../src/es-module/index.ts","../src/RealmRecord.ts","../src/es-module/helpers.ts","../src/index.ts","../src/polyfill.ts"],"sourcesContent":["import type { GlobalObject, RealmRecord } from './type';\nimport type { Utils } from '.';\n\nexport const GLOBAL: GlobalObject = window as any;\nexport const define = Object.defineProperty;\nexport const _ = { debug: false };\n\nconst { log: rawLog, warn } = console;\n\nexport function log(msg: any) {\n    if (_.debug) {\n        rawLog('[DEBUG]');\n        if (isObject(msg)) {\n            warn(msg);\n        } else {\n            rawLog(msg);\n        }\n    }\n}\n\nexport let apply: typeof Reflect['apply'];\nif (GLOBAL.Reflect) {\n    apply = Reflect.apply;\n} else {\n    const applyOfFunction = Function.prototype.apply;\n    apply = function (target: Function, ctx: any, args: ArrayLike<any>) {\n        return applyOfFunction.call(target, ctx, args);\n    };\n}\n\nconst replaceOfString = String.prototype.replace;\n\nexport function replace(\n    str: string,\n    ...args: [\n        string | RegExp,\n        string | ((substring: string, ...args: any[]) => string)\n    ]\n) {\n    return apply(replaceOfString, str, args);\n}\n\nexport function isObject(val: any): val is Record<PropertyKey, any> {\n    return val ? typeof val === 'object' : false;\n}\n\nexport let { assign, keys } = Object;\nif (!assign) {\n    assign = function (target: Record<PropertyKey, any>) {\n        const args = arguments;\n        for (let i = 1, { length } = args; i < length; ++i) {\n            const source = args[i];\n            if (isObject(source)) {\n                for (const key of keys(source)) {\n                    target[key] = source[key];\n                }\n            }\n        }\n        return target;\n    };\n}\n\nexport function wrapError(\n    reason: any,\n    { intrinsics }: RealmRecord,\n    captured = false\n): Error {\n    log(reason);\n    if (captured) {\n        if (!reason._) {\n            return new intrinsics[reason.name as 'SyntaxError'](reason.message);\n        }\n        reason = reason._;\n    }\n    const { TypeError } = intrinsics;\n    const errType = 'Cross-Realm Error: ';\n    if (isObject(reason)) {\n        return new TypeError(errType + reason.name + ': ' + reason.message);\n    }\n    return new TypeError(errType + reason);\n}\n\nexport function getWrappedValue<T>(\n    callerRealm: RealmRecord,\n    value: T,\n    valueRealm: RealmRecord,\n    utils: Utils\n): T {\n    if (typeof value === 'function') {\n        try {\n            return createWrappedFunction(callerRealm, value, valueRealm, utils);\n        } catch (error) {\n            console.log(value);\n            throw utils.wrapError(error, callerRealm);\n        }\n    } else if (isObject(value)) {\n        throw new callerRealm.intrinsics.TypeError(\n            'need primitive or callable, got ' + value\n        );\n    }\n    return value;\n}\n\nfunction createWrappedFunction(\n    callerRealm: RealmRecord,\n    targetFunction: Function,\n    targetRealm: RealmRecord,\n    utils: Utils\n) {\n    let { length, name } = targetFunction;\n    if (typeof length !== 'number' || length < 0) {\n        length = 0;\n    }\n    if (typeof name !== 'string') {\n        name = '';\n    }\n    const wrapped = callerRealm.intrinsics.Function(\n        'params',\n        'return ' + wrappedFunctionInContext.toString()\n    )(arguments);\n    define(wrapped, 'length', { value: length });\n    define(wrapped, 'name', { value: name });\n    return wrapped;\n}\n\n/**\n * Isolated function\n */\nfunction wrappedFunctionInContext() {\n    // @ts-ignore: `params` is in parent scope\n    const [callerRealm, targetFunction, targetRealm, utils] = params as [\n        RealmRecord,\n        Function,\n        RealmRecord,\n        Utils\n    ];\n    let result;\n    try {\n        const args = arguments;\n        const wrappedArgs: any[] = [];\n        for (let i = 0, { length } = args; i < length; ++i) {\n            const wrappedValue = utils.getWrappedValue(\n                targetRealm,\n                args[i],\n                callerRealm,\n                utils\n            );\n            wrappedArgs.push(wrappedValue);\n        }\n        result = utils.apply(\n            targetFunction,\n            targetRealm.globalObject,\n            wrappedArgs\n        );\n    } catch (error) {\n        throw utils.wrapError(error, callerRealm);\n    }\n    return utils.getWrappedValue(callerRealm, result, targetRealm, utils);\n}\n\nexport const globalReservedProps = [\n    // The global properties of ECMAScript 2022\n    'globalThis',\n    'Infinity',\n    'NaN',\n    'undefined',\n    'eval',\n    'isFinite',\n    'isNaN',\n    'parseFloat',\n    'parseInt',\n    'decodeURI',\n    'decodeURIComponent',\n    'encodeURI',\n    'encodeURIComponent',\n    'AggregateError',\n    'Array',\n    'ArrayBuffer',\n    'Atomics',\n    'BigInt',\n    'BigInt64Array',\n    'BigUint64Array',\n    'Boolean',\n    'DataView',\n    'Date',\n    'Error',\n    'EvalError',\n    'FinalizationRegistry',\n    'Float32Array',\n    'Float64Array',\n    'Function',\n    'Int8Array',\n    'Int16Array',\n    'Int32Array',\n    'Map',\n    'Number',\n    'Object',\n    'Promise',\n    'Proxy',\n    'RangeError',\n    'ReferenceError',\n    'RegExp',\n    'Set',\n    'SharedArrayBuffer',\n    'String',\n    'Symbol',\n    'SyntaxError',\n    'TypeError',\n    'Uint8Array',\n    'Uint8ClampedArray',\n    'Uint16Array',\n    'Uint32Array',\n    'URIError',\n    'WeakMap',\n    'WeakRef',\n    'WeakSet',\n    'Atomics',\n    'JSON',\n    'Math',\n    'Reflect',\n\n    // Easy to debug\n    'console',\n] as const;\n","import type {\n    BuiltinShadowRealm,\n    RealmRecord,\n    ShadowRealmConstructor,\n} from './type';\nimport type { Utils } from '.';\n\nexport function defineShadowRealmCtor(\n    globalRealmRec: RealmRecord,\n    utils: Utils\n) {\n    utils.define(globalRealmRec.globalObject, 'ShadowRealm', {\n        configurable: true,\n        writable: true,\n        value: createShadowRealmCtor(globalRealmRec, utils),\n    });\n}\n\nexport function createShadowRealmCtor(\n    globalRealmRec: RealmRecord,\n    utils: Utils\n): ShadowRealmConstructor {\n    const createInContext = globalRealmRec.intrinsics.eval(\n        '(' + createShadowRealmCtorInContext.toString() + ')'\n    );\n    const Ctor = createInContext(globalRealmRec, utils);\n    utils.define(Ctor, '__debug', {\n        get: () => utils._.debug,\n        set: (val) => (utils._.debug = val),\n    });\n    return Ctor;\n}\n\nfunction createShadowRealmCtorInContext(\n    globalRealmRec: RealmRecord,\n    utils: Utils\n) {\n    const { Function, Promise, String, Symbol, TypeError } =\n        globalRealmRec.intrinsics;\n    const {\n        apply,\n        define,\n        dynamicImportPattern,\n        dynamicImportReplacer,\n        getWrappedValue,\n        isObject,\n        replace,\n        wrapError,\n    } = utils;\n    const { toString } = Function;\n\n    /**\n     * ShadowRealm Class\n     */\n    const Constructor = function ShadowRealm(this: BuiltinShadowRealm) {\n        if (!(this instanceof Constructor)) {\n            throw new TypeError('Constructor requires a new operator');\n        }\n        const realmRec = utils.createRealmRecord(globalRealmRec, utils);\n        define(this, '__realm', { value: realmRec });\n    };\n\n    const { prototype } = Constructor;\n    const TRUE = true;\n\n    define(prototype, 'evaluate', {\n        configurable: TRUE,\n        writable: TRUE,\n        value: evaluate,\n    });\n    define(prototype, 'importValue', {\n        configurable: TRUE,\n        writable: TRUE,\n        value: importValue,\n    });\n    if (Symbol && Symbol.toStringTag) {\n        define(prototype, Symbol.toStringTag, {\n            configurable: TRUE,\n            value: 'ShadowRealm',\n        });\n    }\n\n    function evaluate(this: BuiltinShadowRealm, sourceText: string) {\n        const realmRec = isObject(this) ? this.__realm : ({} as RealmRecord);\n        if (!realmRec.intrinsics) {\n            throw new TypeError('must be called on ShadowRealm object');\n        }\n        if (typeof sourceText !== 'string') {\n            throw new TypeError('evaluate expects a string');\n        }\n        sourceText = replace(\n            sourceText,\n            dynamicImportPattern,\n            dynamicImportReplacer\n        );\n        let result: any;\n        try {\n            result = evalWithCatch(sourceText, realmRec);\n        } catch (error) {\n            throw wrapError(error, globalRealmRec, TRUE);\n        }\n        return getWrappedValue(globalRealmRec, result, realmRec, utils);\n    }\n\n    function evalWithCatch(x: string, realmRec: RealmRecord) {\n        x = replace(x, dynamicImportPattern, dynamicImportReplacer);\n        x = apply(toString, Function(x), []);\n        x =\n            '\"use strict\";undefined;try' +\n            replace(x, /[^{]+/, '') +\n            'catch(e){throw{_:e}}';\n        utils.log(x);\n        const { globalObject } = realmRec;\n        // @ts-ignore\n        globalObject.eval = realmRec.intrinsics;\n        return apply(realmRec.evalInContext, globalObject, [x]);\n    }\n\n    function importValue(\n        this: BuiltinShadowRealm,\n        specifier: string,\n        bindingName: string\n    ) {\n        const realmRec = isObject(this) ? this.__realm : ({} as RealmRecord);\n        if (!realmRec.intrinsics) {\n            throw new TypeError('must be called on ShadowRealm object');\n        }\n        specifier = String(specifier);\n        if (typeof bindingName !== 'string') {\n            throw new TypeError('bindingName is not string');\n        }\n        return new Promise((resolve, reject) => {\n            realmRec.globalObject\n                .__import(specifier)\n                .then((exports) => {\n                    if (!(bindingName in exports)) {\n                        throw new TypeError(\n                            '\"' +\n                                specifier +\n                                '\" has no export named \"' +\n                                bindingName +\n                                '\"'\n                        );\n                    }\n                    const wrappedValue = getWrappedValue(\n                        globalRealmRec,\n                        exports[bindingName],\n                        realmRec,\n                        utils\n                    );\n                    resolve(wrappedValue);\n                })\n                .catch((reason) => {\n                    const error = wrapError(reason, globalRealmRec);\n                    reject(error);\n                });\n        });\n    }\n\n    return Constructor;\n}\n","import type { Module, RealmRecord } from '../type';\nimport type { Utils } from '..';\n\nexport function addEsModuleHelpers(realmRec: RealmRecord, utils: Utils) {\n    const evalInContext = realmRec.intrinsics.eval(\n        '(' + addEsModuleHelpersInContext.toString() + ')'\n    );\n    evalInContext(realmRec, utils);\n}\n\nfunction addEsModuleHelpersInContext(realmRec: RealmRecord, utils: Utils) {\n    const { globalObject, intrinsics } = realmRec;\n    const { apply, define, GLOBAL } = utils;\n    const {\n        Array: {\n            prototype: { push },\n        },\n        Object: { create },\n        Promise,\n        Symbol,\n    } = intrinsics;\n    const { fetch, URL } = GLOBAL;\n    const { all } = Promise;\n    const { then } = Promise.prototype;\n\n    let moduleExports: Record<PropertyKey, any> | undefined;\n    const moduleCache: Record<string, Module> = {};\n\n    define(globalObject, '__import', { value: dynamicImport });\n    define(globalObject, '__from', { value: getModule });\n    define(globalObject, '__export', {\n        set: (val) => utils.assign(moduleExports!, val),\n    });\n    define(globalObject, '__default', {\n        set: (val) => (moduleExports!.default = val),\n    });\n\n    function getModule(specifier: string, base: string): object {\n        const { href } = new URL(specifier, base);\n        const module = moduleCache[href];\n        if (module && module.exports) {\n            return module.exports;\n        }\n        throw new intrinsics.Error('Module does not exist (' + specifier + ')');\n    }\n\n    function dynamicImport(\n        specifier: string,\n        base = GLOBAL.location.href\n    ): Promise<object> {\n        const { href } = new URL(specifier, base);\n        return new Promise((resolve, reject) => {\n            const module = moduleCache[href];\n            if (module && module.exports) {\n                return resolve(module.exports);\n            }\n            loadModule(href)\n                .then((text) => {\n                    resolve(parseModule(href, text));\n                })\n                .catch(reject);\n        });\n    }\n\n    function loadModule(href: string): Promise<string> {\n        let module = moduleCache[href];\n        if (module) {\n            return module.promise!;\n        }\n        const promise = fetch(href, {\n            credentials: 'same-origin',\n        })\n            .then((response) => {\n                if (response.status === 200) {\n                    return response.text();\n                }\n                throw {\n                    _: new intrinsics.TypeError(\n                        'Failed to fetch dynamically imported module: ' + href\n                    ),\n                };\n            })\n            .then(\n                (sourceText) => {\n                    const [text, fromList] =\n                        utils.transformEsmSyntax(sourceText);\n                    const promiseList: Promise<string>[] = [];\n                    for (let i = 0, { length } = fromList; i < length; ++i) {\n                        const { href: subHref } = new URL(fromList[i], href);\n                        fromList[i] = subHref;\n                        apply(push, promiseList, [loadModule(subHref)]);\n                    }\n                    const allPromise = apply(all, Promise, [promiseList]);\n                    return apply(then, allPromise, [\n                        (results: any[]) => {\n                            for (\n                                let i = 0, { length } = results;\n                                i < length;\n                                ++i\n                            ) {\n                                parseModule(fromList[i], results[i]);\n                            }\n                            return 'var __meta={url:\"' + href + '\"};' + text;\n                        },\n                    ]);\n                },\n                (reason) => {\n                    if (reason._) {\n                        throw reason._;\n                    }\n                    throw new intrinsics[reason.name as 'Error'](\n                        reason.message\n                    );\n                }\n            );\n        module = moduleCache[href] = { promise } as Module;\n        return promise;\n    }\n\n    function parseModule(href: string, text: string) {\n        moduleExports = create(null);\n        if (Symbol && Symbol.toStringTag) {\n            define(moduleExports, Symbol.toStringTag, {\n                value: 'Module',\n            });\n        }\n        globalObject.eval(text);\n        const module = moduleCache[href];\n        module.exports = moduleExports!;\n        moduleExports = undefined;\n        return module.exports;\n    }\n}\n","import type { GlobalObject, RealmRecord } from './type';\nimport type { Utils } from '.';\n\nexport function createRealmRecord(parentRealmRec: RealmRecord, utils: Utils) {\n    const { document } = parentRealmRec.intrinsics;\n    const iframe = document.createElement('iframe');\n    iframe.name = 'ShadowRealm';\n    document.head.appendChild(iframe);\n    const createInContext = (iframe.contentWindow as GlobalObject).eval(\n        '(' + createRealmRecordInContext.toString() + ')'\n    );\n    return createInContext(utils);\n}\n\nfunction createRealmRecordInContext(utils: Utils) {\n    const win = window;\n    const { Function: RawFunction, Object, Symbol } = win;\n    const { getOwnPropertyNames } = Object;\n    const {\n        apply,\n        define,\n        dynamicImportPattern,\n        dynamicImportReplacer,\n        replace,\n    } = utils;\n    const intrinsics = {} as GlobalObject;\n    const globalObject = {} as GlobalObject;\n    let UNDEFINED: undefined;\n\n    if (Symbol && Symbol.unscopables) {\n        // Prevent escape from the `with` environment\n        define(globalObject, Symbol.unscopables, {\n            value: Object.seal(Object.create(null)),\n        });\n    }\n\n    // Handle window object\n    for (const key of getOwnPropertyNames(win) as any[]) {\n        intrinsics[key] = win[key];\n        const isReserved = utils.globalReservedProps.indexOf(key) !== -1;\n        const descriptor = Object.getOwnPropertyDescriptor(win, key)!;\n        if (key === 'eval') {\n            defineSafeEval();\n        } else if (isReserved) {\n            define(globalObject, key, descriptor); // copy to new global object\n        }\n        if (descriptor.configurable) {\n            delete win[key];\n        } else if (descriptor.writable) {\n            win[key] = UNDEFINED as any;\n        } else if (!isReserved) {\n            // Intercept properties that cannot be deleted\n            define(globalObject, key, { value: UNDEFINED });\n        }\n    }\n\n    if (intrinsics.EventTarget) {\n        // Intercept the props of EventTarget.prototype\n        for (const key of getOwnPropertyNames(\n            intrinsics.EventTarget.prototype\n        )) {\n            if (key !== 'constructor') {\n                define(win, key, { value: UNDEFINED });\n            }\n        }\n    }\n\n    globalObject.globalThis = globalObject;\n    globalObject.Function = createSafeFunction();\n\n    const evalInContext = RawFunction('with(this)return eval(arguments[0])');\n    const realmRec = { intrinsics, globalObject, evalInContext } as RealmRecord;\n\n    utils.defineShadowRealmCtor(realmRec, utils);\n    utils.addEsModuleHelpers(realmRec, utils);\n\n    return realmRec;\n\n    function defineSafeEval() {\n        let isInnerCall = false;\n        const safeEval = createSafeEval();\n        define(globalObject, 'eval', {\n            get() {\n                if (isInnerCall) {\n                    isInnerCall = false;\n                    return intrinsics.eval; // used by safe eval\n                }\n                return safeEval;\n            },\n            set(val) {\n                isInnerCall = val === intrinsics;\n            },\n        });\n    }\n\n    function createSafeEval() {\n        return {\n            eval(x: string) {\n                // `'use strict'` is used to enable strict mode\n                // `undefined`  is used to ensure that the return value remains unchanged\n                x =\n                    '\"use strict\";undefined;' +\n                    replace(x, dynamicImportPattern, dynamicImportReplacer);\n                utils.log(x);\n                // @ts-ignore: `intrinsics` is the key to use raw `eval`\n                globalObject.eval = intrinsics;\n                return apply(evalInContext, globalObject, [x]);\n            },\n        }.eval; // fix: TS1215: Invalid use of 'eval'\n    }\n\n    function createSafeFunction(): FunctionConstructor {\n        const { toString } = RawFunction;\n        const Ctor = function Function() {\n            const rawFn = apply(RawFunction, null, arguments);\n            let fnStr = apply(toString, rawFn, []);\n            fnStr = replace(fnStr, dynamicImportPattern, dynamicImportReplacer);\n            fnStr =\n                'with(this)return function(){\"use strict\";return ' +\n                fnStr +\n                '}()';\n            utils.log(fnStr);\n            const wrapFn = RawFunction(fnStr);\n            const safeFn: Function = apply(wrapFn, globalObject, []);\n            return function (this: any) {\n                const ctx = this === win ? undefined : this;\n                return apply(safeFn, ctx, arguments);\n            };\n        };\n        Ctor.prototype = RawFunction.prototype;\n        Ctor.prototype.constructor = Ctor;\n        return Ctor as any;\n    }\n}\n","const moduleSpecifiers: string[] = [];\nconst exportedNames: string[] = [];\n\n\n/**\n * Syntax:\n *   import(\"module-name\");  =>  __import(\"module-name\");\n */\nexport const dynamicImportPattern = /(^|[^.$])(\\bimport\\s*(\\(|\\/[/*]))/g;\nexport const dynamicImportReplacer = '$1__$2';\n\n\nconst exportAndImportPattern = '' +\n    '\\\\bexport\\\\b(' +\n        '\\\\s+(' +\n            // export let name1, name2, …, nameN; // also var, const\n            // export let name1 = …, name2 = …, …, nameN; // also var, const\n            // export const { name1, name2: bar } = o;\n            '(var|let|const)\\\\s+([^;]+)|' +\n            // export function FunctionName(){...}\n            '(async\\\\s+)?function(\\\\s+|\\\\s*\\\\*\\\\s*)([^\\\\s(]+)|' +\n            // export class ClassName {...}\n            'class\\\\s+([^\\\\s{]+)|' +\n            // export default expression;\n            'default\\\\s+(' +\n                // export default function (…) { … }\n                '(async\\\\s+)?function(\\\\s+|\\\\s*\\\\*\\\\s*)([^\\\\s(]+)|' +\n                // export default class ClassName {...}\n                'class\\\\s+([^\\\\s{]+)|' +\n            ')?' +\n        ')|' +\n        '\\\\s*(' +\n            // export * from …; // does not set the default export\n            '\\\\*\\\\s*(' +\n                // export * as name1 from …; // Draft ECMAScript® 2O21\n                'as\\\\s+(\\\\S+)\\\\s+' +\n            ')?from\\\\s*(\"[^\"]+\"|\\'[^\\']+\\'|`[^`]+`)|' +\n            // export { name1, variable2 as name2, …, nameN };\n            // export { name1, import2 as name2, …, nameN } from …;\n            // export { default } from …;\n            '{([^}]+)}(\\\\s*from\\\\s*(\"[^\"]+\"|\\'[^\\']+\\'|`[^`]+`))?' +\n        ')' +\n    ')|' +\n    '\\\\bimport\\\\b(' +\n        // import \"module-name\";\n        '\\\\s*(' +\n            '(' +\n                // import { e1, e2, e3 as alias } from \"module-name\";\n                '{([^}]+)}\\\\s*|' +\n                // import * as name from \"module-name\";\n                '\\\\*\\\\s*as\\\\s+(\\\\S+)\\\\s+' +\n            ')from\\\\s*' +\n        ')?|' +\n        '\\\\s+([^{*\"\\'`]+)(' +\n            // import defaultExport from \"module-name\";\n            '\\\\s+from|' +\n            '\\\\s*,\\\\s*(' +\n                // import defaultExport, { export [ , [...] ] } from \"module-name\";\n                '{([^}]+)}\\\\s*|' +\n                // import defaultExport, * as name from \"module-name\";\n                '\\\\*\\\\s*as\\\\s+(\\\\S+)\\\\s+' +\n            ')from' +\n        ')\\\\s*' +\n    ')(\"[^\"]+\"|\\'[^\\']+\\'|`[^`]+`)';\n\n\nconst aliasPattern = /([^\\s,]+)\\s+as\\s+([^\\s,]+)/g;\n\n\nconst patternAndReplacers: { p: RegExp, r: any }[] = [\n    {\n        p: RegExp(exportAndImportPattern, 'g'),\n        r(\n            m: string,\n            e1: string, e2: string, e3: string, e4: string, e5: string,\n            e6: string, e7: string, e8: string, e9: string, e10: string,\n            e11: string, e12: string, e13: string, e14: string, e15: string,\n            e16: string, e17: string, e18: string, e19: string, e20: string,\n            i1: string, i2: string, i3: string, i4: string, i5: string,\n            i6: string, i7: string, i8: string, i9: string, i10: string,\n            specifier: string,\n        ) {\n            // export let name1 = …, name2 = …, …, nameN; // also var, const\n            if (e4) {\n                for (const str of e4.split(',')) {\n                    str.replace(\n                        /^\\s*([^\\s={}:]+)\\s*($|=|})|[:{]\\s*([^\\s={}:]+)\\s*($|=|})/, \n                        (m: string, p1: string, p2: string, p3: string) => {\n                            exportedNames.push(p1 || p3);\n                            return m;\n                        }\n                    );\n                }\n                return e2;\n            }\n            // export function FunctionName(){...}\n            if (e7) {\n                return '__export={' + e7 + ':' + e7 + '};' + e2;\n            }\n            // export class ClassName {...}\n            if (e8) {\n                exportedNames.push(e8);\n                return e2;\n            }\n            // export default function (…) { … }\n            if (e12) {\n                return '__default=' + e12 + ';' + e9;\n            }\n            // export default class ClassName {...}\n            if (e13) {\n                exportedNames.push(e13);\n                return e2;\n            }\n            // export default expression;\n            if (e2) {\n                return e2.replace(/^default/, '__default=');\n            }\n            if (e17) {\n                moduleSpecifiers.push(e17);\n                // export * as name1 from …; // Draft ECMAScript® 2O21\n                if (e16) {\n                    return '__export={' + e16 + ':__from(' + e17 + ',__meta.url)}';\n                }\n                // export * from …; // does not set the default export\n                return '__export=__from(' + e17 + ',__meta.url)';\n            }\n            // export { name1, import2 as name2, …, nameN } from …;\n            if (e20) {\n                moduleSpecifiers.push(e20);\n                const exports: string[] = [];\n                e18.replace(/([^\\s,]+)(\\s+as\\s+([^\\s,]+))?/g, (m: string, p1: string, p2:string, p3:string) => {\n                    exports.push((p3 || p1) + ':m.' + p1);\n                    return m;\n                });\n                return ';(function(){' +\n                    'var m=__from(' + e20 + ',__meta.url);' +\n                    '__export={' + exports.join() + '}' +\n                '}())';\n            }\n            // export { name1, variable2 as name2, …, nameN };\n            if (e18) {\n                const params = e18.replace(aliasPattern, '$2:$1');\n                return '__export={' + params + '}';\n            }\n\n            if (specifier) {\n                moduleSpecifiers.push(specifier);\n                const fromModule = '=__from(' + specifier + ',__meta.url)';\n                // import { e1, e2, e3 as alias } from \"module-name\";\n                if (i4) {\n                    const params = i4.replace(aliasPattern, '$1:$2');\n                    return 'const{' + params + '}' + fromModule;\n                }\n                // import * as name from \"module-name\";\n                if (i5) {\n                    return 'var ' + i5 + fromModule;\n                }\n                // import defaultExport, { export [ , [...] ] } from \"module-name\";\n                if (i9) {\n                    const params = i9.replace(aliasPattern, '$1:$2');\n                    return 'const{' + params + '}' + fromModule + ',' + i6 + fromModule + '.default';\n                }\n                // import defaultExport, * as name from \"module-name\";\n                if (i10) {\n                    return 'var ' + i10 + fromModule + ',' + i6 + '=' + i10 + '.default';\n                }\n                // import defaultExport from \"module-name\";\n                if (i6) {\n                    return 'var ' + i6 + fromModule + '.default';\n                }\n                // import \"module-name\";\n                return specifier;\n            }\n        },\n    },\n    {\n        /**\n         * Syntax:\n         *   import.meta  =>  __meta\n         */\n        p: /\\bimport\\.meta\\b/g,\n        r: '__meta',\n    },\n    {\n        p: dynamicImportPattern,\n        r: dynamicImportReplacer,\n    },\n];\n\n\nexport function transformEsmSyntax(sourceText: string) {\n    for (const { p, r } of patternAndReplacers) {\n        sourceText = sourceText.replace(p, r);\n    }\n    if (exportedNames.length) {\n        for (let i = exportedNames.length - 1; i >=0; --i) {\n            exportedNames[i] += ':' + exportedNames[i];\n        }\n        sourceText += ';__export={' + exportedNames.join() + '}';\n        exportedNames.length = 0;\n    }\n    const fromList: string[] = [];\n    for (let i = 0, { length } = moduleSpecifiers; i < length; ++i) {\n        const specifier = moduleSpecifiers[i];\n        fromList.push(specifier.substring(1, specifier.length - 1));\n    }\n    moduleSpecifiers.length = 0;\n    return [sourceText, fromList] as const;\n}\n","import * as helpers from './helpers';\nimport { addEsModuleHelpers } from './es-module';\nimport { createRealmRecord } from './RealmRecord';\nimport { createShadowRealmCtor, defineShadowRealmCtor } from './ShadowRealm';\nimport {\n    dynamicImportPattern,\n    dynamicImportReplacer,\n    transformEsmSyntax,\n} from './es-module/helpers';\nimport type { RealmRecord } from './type';\n\nexport const utils = helpers.assign(\n    {\n        addEsModuleHelpers,\n        createRealmRecord,\n        createShadowRealmCtor,\n        defineShadowRealmCtor,\n        dynamicImportPattern,\n        dynamicImportReplacer,\n        transformEsmSyntax,\n    },\n    helpers\n);\n\nexport type Utils = typeof utils;\n\nexport default helpers.GLOBAL.ShadowRealm ||\n    createShadowRealmCtor({ intrinsics: helpers.GLOBAL } as RealmRecord, utils);\n","import { GLOBAL } from './helpers';\nimport { defineShadowRealmCtor } from './ShadowRealm';\nimport type { RealmRecord, ShadowRealmConstructor } from './type';\nimport { utils } from '.';\n\nif (!GLOBAL.ShadowRealm) {\n    defineShadowRealmCtor(\n        { intrinsics: GLOBAL, globalObject: GLOBAL } as RealmRecord,\n        utils\n    );\n}\n\ndeclare global {\n    interface Window {\n        ShadowRealm: ShadowRealmConstructor;\n    }\n    var ShadowRealm: ShadowRealmConstructor;\n}\n"],"names":["apply","GLOBAL","window","define","Object","defineProperty","_","debug","rawLog","console","warn","log","msg","isObject","Reflect","applyOfFunction_1","Function","prototype","target","ctx","args","call","replaceOfString","String","replace","val","assign","keys","wrappedFunctionInContext","result","_a","params","callerRealm","targetFunction","targetRealm","utils","arguments","wrappedArgs","i","length_2","wrappedValue","getWrappedValue","push","globalObject","error","wrapError","length_1","source","_i","key","str","reason","captured","intrinsics","name","message","TypeError","errType","value","valueRealm","createWrappedFunction","length","wrapped","toString","defineShadowRealmCtor","globalRealmRec","configurable","writable","createShadowRealmCtor","Ctor","eval","createShadowRealmCtorInContext","createInContext","get","set","Promise","Symbol","dynamicImportPattern","dynamicImportReplacer","Constructor","ShadowRealm","this","realmRec","createRealmRecord","TRUE","evaluate","sourceText","__realm","evalWithCatch","x","evalInContext","importValue","specifier","bindingName","resolve","reject","__import","then","exports","catch","toStringTag","addEsModuleHelpersInContext","moduleExports","create","fetch","URL","all","moduleCache","loadModule","href","module","promise","credentials","response","status","text","transformEsmSyntax","fromList","promiseList","subHref","allPromise","results","parseModule","undefined","base","location","Error","default","createRealmRecordInContext","UNDEFINED","win","RawFunction","getOwnPropertyNames","unscopables","seal","isReserved","globalReservedProps","indexOf","descriptor","getOwnPropertyDescriptor","defineSafeEval","EventTarget","_c","_b","globalThis","createSafeFunction","rawFn","fnStr","wrapFn","safeFn","constructor","addEsModuleHelpers","isInnerCall","safeEval","moduleSpecifiers","exportedNames","aliasPattern","patternAndReplacers","p","RegExp","r","m","e1","e2","e3","e4","e5","e6","e7","e8","e9","e10","e11","e12","e13","e14","e15","e16","e17","e18","e19","e20","i1","i2","i3","i4","i5","i6","i7","i8","i9","i10","split","p1","p2","p3","exports_1","join","fromModule","helpers.assign","parentRealmRec","document","iframe","createElement","head","appendChild","contentWindow","patternAndReplacers_1","substring","helpers","helpers.GLOBAL"],"mappings":"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"}